# Cognitive Photonic Radar AI System - Technical Documentation

## 1. Project Overview
This project implements a **Cognitive Photonic Radar** system that leverages AI, photonic physics simulation, and advanced signal processing to detect, track, and classify targets (drones, aircraft, missiles) in real-time. It features a "Cyberpunk Orbital Command" interface and includes advanced modules for Electronic Warfare (EW) defense, security hardening, and explainable AI (XAI).

## 2. System Architecture

The system follows a modular data processing pipeline:
1.  **Signal Acquisition**: Generates synthetic photonic radar signals or reads from RTL-SDR hardware.
2.  **Signal Processing**: Converts raw time-domain IQ samples into Range-Doppler Maps and Spectrograms.
3.  **Target Detection**: Classical CFAR algorithms identify potential targets in the Range-Doppler domain.
4.  **AI Classification**: A 3-branch CNN analyzes the signal maps and metadata to classify the target.
5.  **Tracking**: A Kalman Filter tracks verified targets over time in 3D space.
6.  **Cognitive Control**: A Reinforcement Learning (RL) agent optimizes radar parameters (gain, waveform) based on performance.
7.  **EW Defense**: Analyzes signal statistics to detect and counter jamming attacks.

### Repository Structure
```
├── app.py                     # Main Streamlit Dashboard Application
├── launcher.py                # Setup & Launch Script
├── src/
│   ├── photonic_signal_model.py # Physics-based signal generation
│   ├── detection.py           # Signal Processing & CFAR Algorithms
│   ├── model_pytorch.py       # PyTorch AI Model Architecture
│   ├── tracker.py             # Multi-Target Kalman Filter
│   ├── cognitive_controller.py# Q-Learning RL Agent
│   ├── ew_defense.py          # Electronic Warfare Defense
│   ├── security.py            # Security & Integrity Modules
│   ├── config.yaml            # Central System Configuration
│   └── ... (utils)
├── data/                      # Training Datasets
└── results/                   # Model weights, logs, and artifacts
```

---

## 3. detailed Component Analysis

### 3.1 Photonic Signal Calculation (`src/photonic_signal_model.py`)
This module simulates the physics of a photonic radar system using **Optical Heterodyning**.

#### Mathematical Model
The RF signal is generated by beating two lasers (Signal $E_s$ and Local Oscillator $E_{lo}$) on a photodetector.

1.  **Laser Fields**:
    $$ E(t) = A \cdot e^{j(\omega t + \phi(t))} $$
    where $\phi(t)$ is the **Laser Phase Noise**, modeled as a Wiener Process:
    $$ \phi(t+\Delta t) = \phi(t) + \sqrt{2\pi \cdot \Delta f \cdot \Delta t} \cdot \mathcal{N}(0,1) $$
    ($\Delta f$ is the laser linewidth).

2.  **Beat Frequency**:
    The photodetector outputs the squared magnitude of the sum of fields, resulting in a difference frequency term:
    $$ I_{PD}(t) \propto \cos((\omega_s - \omega_{lo})t + (\phi_s(t) - \phi_{lo}(t))) $$

3.  **Coherence Loss**:
    Temperature drift reduces coherence time, modeled as an exponential amplitude decay:
    $$ A(t) = A_0 \cdot e^{-|\Delta T| / T_{coh}} $$

4.  **Beamforming**:
    Time delays ($\tau$) are applied using a **Windowed Sinc Fractional Delay Filter** to steer the beam. Jitter is added to $\tau$ to simulate hardware imperfections.

---

### 3.2 Signal Processing & Detection (`src/detection.py`)

#### 1. Range-Doppler Map (RDM)
Generated via **2D Fast Fourier Transform (FFT)** on the pulse matrix.
-   **Range Axis**: Fast-time FFT.
-   **Doppler Axis**: Slow-time FFT.
$$ RDM(r, v) = | \mathcal{F}_{2D} \{ S(t_{slow}, t_{fast}) \} | $$

#### 2. CFAR Detection (CA-CFAR)
**Cell-Averaging Constant False Alarm Rate** is used to detect targets against varying noise floors.

*   **Logic**:
    1.  Select a **Cell Under Test (CUT)**.
    2.  Define a **Guard Region** around it (ignored).
    3.  Define a **Training Region** around the guard.
    4.  Calculate Noise Level ($P_n$) = Average power of Training Region.
    5.  Threshold $T = \alpha \cdot P_n$.
    6.  If $P_{CUT} > T$, declare detection.

*   **Alpha ($\alpha$) Calculation**:
    $$ \alpha = N \cdot (P_{fa}^{-1/N} - 1) $$
    where $N$ is the number of training cells and $P_{fa}$ is the desired probability of false alarm ($10^{-6}$).

---

### 3.3 Multi-Target Tracking (`src/tracker.py`)

Uses a **Kalman Filter** coupled with the **Hungarian Algorithm** for data association.

#### Kalman Filter State
State Vector $x = [p_x, p_y, v_x, v_y]^T$ (Position and Velocity).

1.  **Prediction Step**:
    $$ \hat{x}_{k|k-1} = F \hat{x}_{k-1|k-1} $$
    $$ P_{k|k-1} = F P_{k-1|k-1} F^T + Q $$
    Where $F$ is the state transition model (constant velocity).

2.  **Update Step**:
    $$ K_k = P_{k|k-1} H^T (H P_{k|k-1} H^T + R)^{-1} $$
    $$ \hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k (z_k - H \hat{x}_{k|k-1}) $$
    Where $z_k$ is the measurement (detected range/doppler) and $K_k$ is the Kalman Gain.

#### Data Association
The **Hungarian Algorithm** minimizes the total Euclidean distance between predicted track positions and new measurements to assign IDs.

---

### 3.4 Cognitive Control (Reinforcement Learning) (`src/cognitive_controller.py`)

A **Q-Learning** agent autonomously optimizes radar parameters.

#### State Space
The agent observes a quantized state tuple:
`[Detection Confidence, Tracking Confidence, False Alarm Rate, Energy Usage, Num Tracks]`

#### Action Space
Discrete combinations of:
*   **Gain**: `[5, 15, 25, 35]` dB
*   **Distance**: `[100, 300, 500, 800]` m
*   **Target Priority**: Class focus (e.g., "Drone", "Missile")

#### Q-Learning Update Rule
$$ Q(s,a) \leftarrow Q(s,a) + \alpha [R + \gamma \max_{a'} Q(s',a') - Q(s,a)] $$
*   $\alpha$: Learning Rate (0.1)
*   $\gamma$: Discount Factor (0.9)
*   $R$: Reward Function

#### Reward Function $R$
$$ R = w_{det} \cdot \Delta Conf_{det} + w_{track} \cdot \Delta Conf_{track} - w_{fa} \cdot FA_{rate} - w_{energy} \cdot Energy $$
Penalizes high energy usage and false alarms; rewards high confidence detections.

---

### 3.5 AI Architecture (`src/model_pytorch.py`)

A **Multi-Modal Convolutional Neural Network**.

1.  **Branch 1 (Range-Doppler)**: 2-Layer CNN (Conv2D -> ReLU -> MaxPool) extracting spatial features.
2.  **Branch 2 (Spectrogram)**: Same architecture, analyzing time-frequency micro-Doppler signatures.
3.  **Branch 3 (Metadata)**: Dense layers processing scalar SNR and phase data.
4.  **Fusion**: Concatenation of all feature vectors.
5.  **Head**: Fully connected layer -> Softmax -> 6 Classes.

---

### 3.6 Electronic Warfare (EW) Defense (`src/ew_defense.py`)

#### 1. Noise Jamming Detection
Monitors the **Signal-to-Noise Ratio (SNR)** history. A rapid drop >5dB signals a noise barrage.

#### 2. Deception Jamming Detection
Monitors the **Target Count**. A sudden spike (e.g., 0 to 50 targets) signals a DRFM (Digital Radio Frequency Memory) repeater attack.

#### 3. Countermeasures (Frequency Hopping)
If jamming is detected, the radar hops to a new carrier frequency:
$$ f_{new} = f_{base} + \Delta f \cdot \text{Permutation}[i] $$

---

## 4. Configuration (`config.yaml`)

| Section | Key | Description |
| :--- | :--- | :--- |
| **Photonic** | `laser_linewidth_hz` | Controls phase noise intensity ($10^3$ Hz). |
| | `beamjitter_std_ns` | Standard deviation of beam steering jitter. |
| **Detection** | `pfa` | Probability of False Alarm ($10^{-6}$). Controls sensitivity. |
| **Cognitive** | `epsilon` | Exploration rate for RL (0.15). |
| **EW** | `snr_threshold_db` | Drop in SNR required to trigger jamming alert (-5.0). |
| **Security** | `tamper_detection_enabled` | If true, hashes files at startup and monitors changes. |

---

## 5. Troubleshooting

*   **"No track positions available yet"**:
    *   **Cause**: Weak signal or high detection threshold.
    *   **Fix**: Increase `Gain` in sidebar or lower `PFA` in System Config.

*   **"Disk quota exceeded"**:
    *   **Cause**: Full GPU libraries (Torch/CuPy) in local venv.
    *   **Fix**: Use `./run_system.sh` to bypass the local environment and use system packages.

*   **Deprecation Warnings**:
    *   Harmless. We have patched most (e.g., `use_column_width` -> `use_container_width`), but library updates may introduce new ones.
