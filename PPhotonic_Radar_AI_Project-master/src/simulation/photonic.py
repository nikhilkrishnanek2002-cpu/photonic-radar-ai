"""
Photonic Radar Signal Generator
==============================

This module simulates the generation of radar signals using microwave photonics principles.
It models the optical heterodyning process where an RF chirp is generated by mixing two
laser tones on a high-speed photodetector.

Key Physics Modeled:
1. Laser Phase Noise: Modeled as a Wiener process (Brownian motion of phase).
2. Optical Heterodyning: Beat frequency generation.
3. FMCW Modulation: Linear frequency sweep of the master laser.

Author: Principal Photonic Radar Scientist
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple, Optional

@dataclass
class PhotonicConfig:
    """Configuration parameters for the Photonic Radar Generator."""
    fs: float = 20e9           # Sampling Frequency (Hz) - High for RF simulation
    duration: float = 10e-6    # Chirp Duration (seconds)
    f_start: float = 8e9       # Start Frequency (Hz) e.g., 8 GHz
    bandwidth: float = 4e9     # Chirp Bandwidth (Hz) e.g., 4 GHz
    laser_linewidth: float = 100e3  # Laser Linewidth (Hz) - e.g., 100 kHz
    optical_power_dbm: float = 10.0 # Optical Power (dBm)
    photodetector_responsivity: float = 0.8 # A/W

def generate_phase_noise(n_samples: int, fs: float, linewidth: float, rng: np.random.Generator) -> np.ndarray:
    """
    Generates laser phase noise using a Wiener process.
    
    phi(k+1) = phi(k) + sqrt(2*pi*dv*dt) * N(0,1)
    """
    dt = 1.0 / fs
    # Standard deviation of phase step
    sigma_phase = np.sqrt(2 * np.pi * linewidth * dt)
    
    # Random steps
    steps = rng.normal(0, sigma_phase, n_samples)
    
    # Cumulative sum to simulate Random Walk (Wiener Process)
    return np.cumsum(steps)

def generate_photonic_signal(config: PhotonicConfig, seed: Optional[int] = None) -> Tuple[np.ndarray, np.ndarray]:
    """
    Simulates the end-to-end photonic radar signal generation.

    Returns:
        t (np.ndarray): Time vector
        signal (np.ndarray): Generated RF signal (voltage at photodetector)
    """
    rng = np.random.default_rng(seed)
    N = int(config.duration * config.fs)
    t = np.arange(N) / config.fs
    
    # 1. Parameter Setup
    # LO Frequency (Virtual Optical Offset)
    # We model everything in baseband equivalent relative to the Optical Carrier (193 THz).
    # Master Laser Freq: f_opt + f_RF(t)
    # Local Oscillator: f_opt
    
    # Convert dBm to Watts
    p_watts = 10 ** ((config.optical_power_dbm - 30) / 10)
    amplitude = np.sqrt(p_watts)
    
    # 2. Generate Phase Noise
    # Independent phase noise for Master Laser (Tx) and LO
    phi_tx = generate_phase_noise(N, config.fs, config.laser_linewidth, rng)
    phi_lo = generate_phase_noise(N, config.fs, config.laser_linewidth, rng)
    
    # 3. FMCW Modulation (Linear Frequency Sweep)
    # f_inst(t) = f_start + (B/T) * t
    slope = config.bandwidth / config.duration
    
    # Phase is integral of frequency: phi = 2*pi * (f_start*t + 0.5*slope*t^2)
    phase_modulation = 2 * np.pi * (config.f_start * t + 0.5 * slope * t**2)
    
    # 4. Total Optical Phase
    # Field Tx: E_tx = A * exp(j * (phase_mod + phi_tx))
    # Field LO: E_lo = A * exp(j * (phi_lo))  (Assume LO is at frequency 0 relative to carrier)
    
    # 5. Photodetection (Square Law Mixing)
    # I_pd = R * |E_tx + E_lo|^2
    # Expanding: |A|^2 + |A|^2 + 2*A^2 * Re(E_tx * E_lo*)
    # The AC term (RF signal) is the cross term.
    
    # RF Component Phase = (phase_mod + phi_tx) - (phi_lo)
    rf_total_phase = phase_modulation + (phi_tx - phi_lo)
    
    # RF Current
    # i_rf(t) = 2 * R * P * cos(theta(t))
    i_rf = 2 * config.photodetector_responsivity * p_watts * np.cos(rf_total_phase)
    
    return t, i_rf

if __name__ == "__main__":
    # Self-test
    cfg = PhotonicConfig(duration=1e-6, bandwidth=1e9)
    t, sig = generate_photonic_signal(cfg, seed=42)
    print(f"Generated Signal: {sig.shape} samples, Mean: {np.mean(sig):.4e}, Std: {np.std(sig):.4e}")
