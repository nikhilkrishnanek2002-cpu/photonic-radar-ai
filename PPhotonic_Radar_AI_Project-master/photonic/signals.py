"""
Photonic Radar Signal Generator
==============================

This module simulates the generation of radar signals using microwave photonics principles.
It models the optical heterodyning process where an RF chirp is generated by mixing two
laser tones on a high-speed photodetector.

Key Physics Modeled:
1. Laser Phase Noise: Modeled as a Wiener process (Brownian motion of phase).
2. Optical Heterodyning: Beat frequency generation.
3. FMCW Modulation: Linear frequency sweep of the master laser.

Author: Principal Photonic Radar Scientist
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple, Optional

@dataclass
class PhotonicConfig:
    """Configuration parameters for the Photonic Radar Generator."""
    fs: float = 20e9           # Sampling Frequency (Hz) - High for RF simulation
    duration: float = 10e-6    # Chirp Duration (seconds)
    f_start: float = 8e9       # Start Frequency (Hz) e.g., 8 GHz
    bandwidth: float = 4e9     # Chirp Bandwidth (Hz) e.g., 4 GHz
    laser_linewidth: float = 100e3  # Laser Linewidth (Hz) - e.g., 100 kHz
    optical_power_dbm: float = 10.0 # Optical Power per line(dBm)
    photodetector_responsivity: float = 0.8 # A/W
    n_comb_lines: int = 1           # Number of coherent lines (OFC mode)
    comb_spacing_hz: float = 10e9   # Spacing between comb lines

def generate_phase_noise(n_samples: int, fs: float, linewidth: float, rng: np.random.Generator) -> np.ndarray:
    """
    Generates laser phase noise using a Wiener process.
    
    phi(k+1) = phi(k) + sqrt(2*pi*dv*dt) * N(0,1)
    """
    dt = 1.0 / fs
    # Standard deviation of phase step
    sigma_phase = np.sqrt(2 * np.pi * linewidth * dt)
    
    # Random steps
    steps = rng.normal(0, sigma_phase, n_samples)
    
    # Cumulative sum to simulate Random Walk (Wiener Process)
    return np.cumsum(steps)

def generate_ofc_signal(config: PhotonicConfig, t: np.ndarray, rng: np.random.Generator) -> np.ndarray:
    """
    Simulates an Optical Frequency Comb (OFC) signal.
    Models multiple phase-locked optical carriers.
    """
    ofc_field = np.zeros(len(t), dtype=complex)
    p_watts = 10 ** ((config.optical_power_dbm - 30) / 10)
    amplitude = np.sqrt(p_watts)
    
    # Common phase noise for all lines (Phase coherence)
    phi_common = generate_phase_noise(len(t), config.fs, config.laser_linewidth, rng)
    
    for i in range(config.n_comb_lines):
        f_offset = i * config.comb_spacing_hz
        # Each line: E_i = A * exp(j * (2*pi*f_i*t + phi_common))
        ofc_field += amplitude * np.exp(1j * (2 * np.pi * f_offset * t + phi_common))
        
    return ofc_field

def generate_photonic_signal(config: PhotonicConfig, seed: Optional[int] = None) -> Tuple[np.ndarray, np.ndarray]:
    """
    Simulates the end-to-end photonic radar signal generation.

    Returns:
        t (np.ndarray): Time vector
        signal (np.ndarray): Generated RF signal (voltage at photodetector)
    """
    rng = np.random.default_rng(seed)
    N = int(config.duration * config.fs)
    t = np.arange(N) / config.fs
    
    # 1. Parameter Setup
    p_watts = 10 ** ((config.optical_power_dbm - 30) / 10)
    
    # 2. Generate Phase Noise and Modulation
    # If comb lines > 1, Tx is an OFC
    if config.n_comb_lines > 1:
        e_tx = generate_ofc_signal(config, t, rng)
        # Apply FMCW modulation to the entire comb? 
        # In a real system, the whole comb can be modulated.
        slope = config.bandwidth / config.duration
        phase_modulation = 2 * np.pi * (config.f_start * t + 0.5 * slope * t**2)
        e_tx *= np.exp(1j * phase_modulation)
    else:
        phi_tx = generate_phase_noise(N, config.fs, config.laser_linewidth, rng)
        slope = config.bandwidth / config.duration
        phase_modulation = 2 * np.pi * (config.f_start * t + 0.5 * slope * t**2)
        e_tx = np.sqrt(p_watts) * np.exp(1j * (phase_modulation + phi_tx))
        
    # 3. Local Oscillator (LO)
    # LO typically doesn't have comb lines unless it's a dual-comb system
    phi_lo = generate_phase_noise(N, config.fs, config.laser_linewidth, rng)
    e_lo = np.sqrt(p_watts) * np.exp(1j * phi_lo)
    
    # 4. Photodetection (Square Law Mixing)
    # I_pd = R * |E_tx + E_lo|^2
    # The AC term is 2 * R * Re(E_tx * E_lo*)
    i_rf = 2 * config.photodetector_responsivity * np.real(e_tx * np.conj(e_lo))
    
    return t, i_rf

if __name__ == "__main__":
    # Self-test
    cfg = PhotonicConfig(duration=1e-6, bandwidth=1e9)
    t, sig = generate_photonic_signal(cfg, seed=42)
    print(f"Generated Signal: {sig.shape} samples, Mean: {np.mean(sig):.4e}, Std: {np.std(sig):.4e}")
